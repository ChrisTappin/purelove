#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Copyright (c) 2016-2017
"""

import os
import sys
import json
import colorama
from dotted import DottedDict
from abc import ABCMeta, abstractmethod

sys.path.append(os.path.join(os.path.dirname(__file__), '../thirdparty'))
colorama.init()


"""
封装调用类，方便以后扩展

"""

class BGLogLevel(object):
    """
    调试级别
    """
    debug = 1
    info = 2
    warning = 3
    error = 4


class BGRef(object):
    """
    引用相关
    """
    url = "相关链接"  # url
    bugfrom = "漏洞来源"  # CVE: 2014-0772



class BGConvert(object):
    """
    参数转换，工具调用
    """
    @staticmethod
    def int_field(string):
        assert isinstance(string, (basestring, int)) #判断是否是来自项目，出错终止点 ...
        return int(string)

    @staticmethod
    def str_field(string):
        assert isinstance(string, basestring)
        return str(string)

    @staticmethod
    def bool_field(string):
        assert isinstance(string, (basestring, int))
        if string.lower() == 'false' or string == '0':
            return False
        return bool(string)

    @staticmethod
    def json_field(string):
        assert isinstance(string, basestring)
        return json.loads(string)

    @staticmethod
    def url_field(string):
        assert isinstance(string, basestring)
        #判断是否以"HTTP"头开始，不是就加上并返回
        domain = string if string.startswith('http') else "http://{domain}".format(domain=string)
        return str(domain)

    @staticmethod
    def email_field(string):
        # TODO: there is no need to implement this in here
        assert isinstance(string, basestring)
        return string


class BGLicense(object):
    """
    相关版权信息
    """
    BG = "PureLoveSploit"

class BGSeverity(object):
    """
    危害等级
    """
    high = '高'
    medium = '中'
    low = '低'
    
class BGHandler(object):
    """
    @设置payload,是否监听
    @Date:2018-1.31
    @Author:Mosin
    """

    #payload设置
    def __init__(self):
        self.payload = ""
        self.pwd = ""
        self.listen = False
        self.payload_fun = ""
        
    def payload(self,payload):
        self.payload = payload
        
    def set_listen(self):
        self.listen = True
        
    def uset_listen(self):
        self.listen = False

    def set_pwd(self,pwd):
        self.pwd = pwd
    
    
class BGType(object):
    """
    漏洞类型描述
    """
    injection = 'SQL注入'
    xss = 'xss跨站脚本攻击'
    xxe = 'xml外部实体攻击'
    file_upload = '任意文件上传'
    file_operation = '任意文件操作'
    file_traversal = '目录遍历'
    rce = '远程命令/代码执行'
    lfi = '本地文件包含'
    rfi = '远程文件包含'
    info_leak = '信息泄漏'
    misconfiguration = '错误配置'
    other = '其他'



class BGExploit(object):
    __metaclass__ = ABCMeta   #虚拟抽象本类

    ref       = BGRef()         #漏洞来源
    type      = BGType()        #漏洞描述
    convert   = BGConvert()     #参数转换
    license   = BGLicense()     #版权
    severity  = BGSeverity()    #漏洞等级
    handler   = BGHandler()     #监听shell

    def __init__(self):
        super(BGExploit, self).__init__()  #初始化
        self.option    = {}                #新增参数
        self.result    = {}                #返回结果
        self.log_level = BGLogLevel.info   #漏洞等级信息默认

    @staticmethod
    def is_sanbox():
        import os
        if os.environ.get('APP_NAME', None):   #获取变量
            return True

    def register_option(self, dict_option):
        assert isinstance(dict_option, dict)
        self.option = DottedDict(dict_option)

    def register_result(self, dict_result):
        assert isinstance(dict_result, dict)
        self.result = DottedDict(dict_result)
        
        """
        payload and exploit框架利用输出
        """
        
    @abstractmethod
    def payload(self):
        pass

    @abstractmethod
    def exploit(self):
        pass


    #4个调试级别
    #调试输出，在payload或者exploit中测试
    def print_debug(self, content):
        if self.log_level <= BGLogLevel.debug:
            if self.is_sanbox():
                print("{content}".format(content=content))
            else:
                print("{debug_color}[debug]: {content} {color_reset}".format(
                    debug_color=colorama.Fore.CYAN, content=content, color_reset=colorama.Fore.RESET))

    def print_info(self, content):
        if self.log_level <= BGLogLevel.info:
            if self.is_sanbox():
                print("{content}".format(content=content))
            else:
                print("{info_color}[info]: {content} {color_reset}".format(
                    info_color=colorama.Fore.GREEN, content=content, color_reset=colorama.Fore.RESET))

    def print_warning(self, content):
        if self.log_level <= BGLogLevel.warning:
            if self.is_sanbox():
                print("{content}".format(content=content))
            else:
                print("{warning_color}[warning]: {content} {color_reset}".format(
                    warning_color=colorama.Fore.YELLOW, content=content, color_reset=colorama.Fore.RESET))

    def print_error(self, content):
        if self.log_level <= BGLogLevel.error:
            if self.is_sanbox():
                print("{content}".format(content=content))
            else:
                print("{error_color}[error]: {content} {color_reset}".format(
                    error_color=colorama.Fore.RED, content=content, color_reset=colorama.Fore.RESET))

